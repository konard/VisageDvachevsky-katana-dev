// Simple CRUD API example with OpenAPI codegen
//
// This example demonstrates:
// 1. Using katana_gen to generate DTOs and routes from OpenAPI spec
// 2. Implementing a simple in-memory repository
// 3. Connecting generated code to the HTTP server
//
// Build and run:
//   cmake --preset examples
//   cmake --build --preset examples --target simple_crud_codegen
//   ./build/examples/examples/codegen/simple_crud/simple_crud_codegen

#include "katana/core/arena.hpp"
#include "katana/core/fd_watch.hpp"
#include "katana/core/http.hpp"
#include "katana/core/io_buffer.hpp"
#include "katana/core/reactor_pool.hpp"
#include "katana/core/router.hpp"
#include "katana/core/shutdown.hpp"
#include "katana/core/tcp_listener.hpp"
#include "katana/core/tcp_socket.hpp"

// Generated files (will be generated by katana_gen)
// #include "generated_dtos.hpp"
// #include "generated_json.hpp"
// #include "generated_routes.hpp"

#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <optional>
#include <sstream>
#include <string>
#include <vector>

using namespace katana;
using namespace katana::http;

// ============================================================================
// Manual DTOs (TODO: Replace with generated code)
// ============================================================================

struct Task {
    int64_t id;
    std::string title;
    std::optional<std::string> description;
    bool completed;

    // Manual JSON serialization (TODO: Replace with generated)
    std::string to_json() const {
        std::ostringstream oss;
        oss << "{\"id\":" << id << ",\"title\":\"" << title << "\"";
        if (description) {
            oss << ",\"description\":\"" << *description << "\"";
        }
        oss << ",\"completed\":" << (completed ? "true" : "false") << "}";
        return oss.str();
    }
};

struct CreateTaskRequest {
    std::string title;
    std::optional<std::string> description;
    bool completed = false;

    // Manual JSON parsing (TODO: Replace with generated)
    static std::optional<CreateTaskRequest> from_json(std::string_view json) {
        // Very simple parsing - in real code use generated parser
        CreateTaskRequest req;

        // Extract title (naive implementation)
        size_t title_pos = json.find("\"title\"");
        if (title_pos == std::string_view::npos)
            return std::nullopt;

        size_t colon_pos = json.find(":", title_pos);
        size_t quote1 = json.find("\"", colon_pos);
        size_t quote2 = json.find("\"", quote1 + 1);

        if (quote1 == std::string_view::npos || quote2 == std::string_view::npos) {
            return std::nullopt;
        }

        req.title = std::string(json.substr(quote1 + 1, quote2 - quote1 - 1));
        req.completed = json.find("\"completed\":true") != std::string_view::npos;

        return req;
    }
};

struct UpdateTaskRequest {
    std::optional<std::string> title;
    std::optional<std::string> description;
    std::optional<bool> completed;

    static std::optional<UpdateTaskRequest> from_json(std::string_view json) {
        UpdateTaskRequest req;
        // Simplified parsing
        return req;
    }
};

// ============================================================================
// In-memory repository
// ============================================================================

class TaskRepository {
public:
    TaskRepository() : next_id_(1) {}

    std::vector<Task> list_all() const {
        std::lock_guard<std::mutex> lock(mutex_);
        std::vector<Task> result;
        result.reserve(tasks_.size());
        for (const auto& [id, task] : tasks_) {
            result.push_back(task);
        }
        return result;
    }

    std::optional<Task> get_by_id(int64_t id) const {
        std::lock_guard<std::mutex> lock(mutex_);
        auto it = tasks_.find(id);
        if (it == tasks_.end()) {
            return std::nullopt;
        }
        return it->second;
    }

    Task create(const CreateTaskRequest& req) {
        std::lock_guard<std::mutex> lock(mutex_);
        int64_t id = next_id_++;
        Task task{id, req.title, req.description, req.completed};
        tasks_[id] = task;
        return task;
    }

    std::optional<Task> update(int64_t id, const UpdateTaskRequest& req) {
        std::lock_guard<std::mutex> lock(mutex_);
        auto it = tasks_.find(id);
        if (it == tasks_.end()) {
            return std::nullopt;
        }

        if (req.title)
            it->second.title = *req.title;
        if (req.description)
            it->second.description = *req.description;
        if (req.completed)
            it->second.completed = *req.completed;

        return it->second;
    }

    bool remove(int64_t id) {
        std::lock_guard<std::mutex> lock(mutex_);
        return tasks_.erase(id) > 0;
    }

private:
    mutable std::mutex mutex_;
    std::map<int64_t, Task> tasks_;
    int64_t next_id_;
};

// ============================================================================
// HTTP Handlers
// ============================================================================

class TaskHandlers {
public:
    explicit TaskHandlers(TaskRepository& repo) : repo_(repo) {}

    // GET /tasks
    response list_tasks(const request& req, request_context& ctx) {
        auto tasks = repo_.list_all();

        std::ostringstream json;
        json << "[";
        for (size_t i = 0; i < tasks.size(); ++i) {
            json << tasks[i].to_json();
            if (i < tasks.size() - 1)
                json << ",";
        }
        json << "]";

        return response::ok(json.str()).with_header("Content-Type", "application/json");
    }

    // POST /tasks
    response create_task(const request& req, request_context& ctx) {
        auto create_req = CreateTaskRequest::from_json(req.body);
        if (!create_req) {
            return response::error(problem_details::bad_request("Invalid JSON body"));
        }

        if (create_req->title.empty()) {
            return response::error(problem_details::bad_request("Title is required"));
        }

        auto task = repo_.create(*create_req);
        return response{201, task.to_json()}.with_header("Content-Type", "application/json");
    }

    // GET /tasks/{id}
    response get_task(const request& req, request_context& ctx) {
        auto id_str = ctx.params.get("id");
        if (!id_str) {
            return response::error(problem_details::bad_request("Missing id parameter"));
        }

        int64_t id = std::stoll(std::string(*id_str));
        auto task = repo_.get_by_id(id);

        if (!task) {
            return response::error(problem_details::not_found("Task not found"));
        }

        return response::ok(task->to_json()).with_header("Content-Type", "application/json");
    }

    // PUT /tasks/{id}
    response update_task(const request& req, request_context& ctx) {
        auto id_str = ctx.params.get("id");
        if (!id_str) {
            return response::error(problem_details::bad_request("Missing id parameter"));
        }

        int64_t id = std::stoll(std::string(*id_str));
        auto update_req = UpdateTaskRequest::from_json(req.body);
        if (!update_req) {
            return response::error(problem_details::bad_request("Invalid JSON body"));
        }

        auto task = repo_.update(id, *update_req);
        if (!task) {
            return response::error(problem_details::not_found("Task not found"));
        }

        return response::ok(task->to_json()).with_header("Content-Type", "application/json");
    }

    // DELETE /tasks/{id}
    response delete_task(const request& req, request_context& ctx) {
        auto id_str = ctx.params.get("id");
        if (!id_str) {
            return response::error(problem_details::bad_request("Missing id parameter"));
        }

        int64_t id = std::stoll(std::string(*id_str));
        bool deleted = repo_.remove(id);

        if (!deleted) {
            return response::error(problem_details::not_found("Task not found"));
        }

        return response{204, ""};
    }

private:
    TaskRepository& repo_;
};

// ============================================================================
// Server setup
// ============================================================================

void handle_connection(tcp_socket sock, reactor& r, router& rt) {
    auto fd = sock.get();
    monotonic_arena arena;
    io_buffer read_buf(arena);
    io_buffer write_buf(arena);

    auto watch =
        r.watch(fd, poll_flags::in, [fd, &r, &rt, &arena, &read_buf, &write_buf](poll_flags flags) {
            if (flags.has_error() || flags.has_hangup()) {
                return;
            }

            if (flags.can_read()) {
                ssize_t n = read_buf.read_from_fd(fd);
                if (n <= 0) {
                    return;
                }

                auto req_result = request::parse(read_buf.readable_span());
                if (!req_result) {
                    return;
                }

                request_context ctx{arena};
                auto resp = dispatch_or_problem(rt, *req_result, ctx);

                write_buf.clear();
                write_buf.append(resp.serialize());
                write_buf.write_to_fd(fd);

                arena.reset();
                read_buf.clear();
            }
        });
}

int main() {
    // Initialize repository
    TaskRepository repo;
    TaskHandlers handlers(repo);

    // Setup routes (TODO: Replace with generated routes)
    route_entry routes[] = {
        {method::get,
         path_pattern::from_literal<"/tasks">(),
         handler_fn([&handlers](const request& req, request_context& ctx) {
             return handlers.list_tasks(req, ctx);
         })},

        {method::post,
         path_pattern::from_literal<"/tasks">(),
         handler_fn([&handlers](const request& req, request_context& ctx) {
             return handlers.create_task(req, ctx);
         })},

        {method::get,
         path_pattern::from_literal<"/tasks/{id}">(),
         handler_fn([&handlers](const request& req, request_context& ctx) {
             return handlers.get_task(req, ctx);
         })},

        {method::put,
         path_pattern::from_literal<"/tasks/{id}">(),
         handler_fn([&handlers](const request& req, request_context& ctx) {
             return handlers.update_task(req, ctx);
         })},

        {method::del,
         path_pattern::from_literal<"/tasks/{id}">(),
         handler_fn([&handlers](const request& req, request_context& ctx) {
             return handlers.delete_task(req, ctx);
         })},
    };

    router rt(routes);

    // Create reactor pool
    reactor_pool pool(1);
    auto& r = pool[0];

    // Setup listener
    tcp_listener listener =
        tcp_listener::create("0.0.0.0", 8080)
            .on_accept([&r, &rt](tcp_socket sock) { handle_connection(std::move(sock), r, rt); })
            .reuse_addr(true)
            .listen_or_throw(128);

    r.watch(
        listener.get(), poll_flags::in, [&listener](poll_flags flags) { listener.accept_one(); });

    std::cout << "Simple CRUD API server listening on http://0.0.0.0:8080\n";
    std::cout << "Try:\n";
    std::cout << "  curl http://localhost:8080/tasks\n";
    std::cout << "  curl -X POST http://localhost:8080/tasks -d "
                 "'{\"title\":\"Buy milk\"}'\n";
    std::cout << "  curl http://localhost:8080/tasks/1\n";

    pool.start();
    pool.wait();

    return 0;
}
